#include "./pokeGame.jsligo"

// reset state
const _ = Test.reset_state ( 2 as nat, list([]) as list <tez> );
const faucet = Test.nth_bootstrap_account(0);
const sender1 : address = Test.nth_bootstrap_account(1);
const _ = Test.log("Sender 1 has balance : ");
const _ = Test.log(Test.get_balance(sender1));

const _ = Test.set_baker(faucet);
const _ = Test.set_source(faucet);

//contract origination
const [taddr, _, _] = Test.originate(main, {
    pokeTraces : Map.empty as map<address, pokeMessage> , 
    feedback : "kiss" , 
    ticketOwnership : Map.empty as map<address,ticket<string>>},
    0 as tez);
const contr = Test.to_contract(taddr);
const contrAddress = Tezos.address(contr);
const _ = Test.log("contract deployed with values : ");
const _ = Test.log(contr);

//functions
const _testPoke = (s : address) : bool => {
    Test.set_source(s);

    const status : test_exec_result = Test.transfer_to_contract(contr, Poke(), 0 as tez);
    Test.log(status);

    return match(status,{
        Fail : (_tee : test_exec_error) => false,
        Success : (_n : nat) => match(Map.find_opt (s, (Test.get_storage(taddr) as storage).pokeTraces), {
                                Some: (pokeMessage: pokeMessage) => { assert_with_error(pokeMessage.feedback == "","feedback "+pokeMessage.feedback+" is not equal to expected "+"(empty)"); assert_with_error(pokeMessage.receiver == contrAddress,"receiver is not equal"); return true; } ,
                                None: () => false
       })
    });
      
  };
  
 
  //********** TESTS *************/
 
  const status = Test.transfer_to_contract(contr, Init(sender1), 0 as tez);
  const _ = Test.log(status);
  const _ = Test.log("*** Check initial ticket is here ***");
  const _ = Test.log(Test.get_storage(taddr));

  const _ = Test.log("*** Run test to pass ***"); 
  const testSender1Poke = _testPoke(sender1);

  const _ = Test.log("*** Run test to fail ***"); 
  const testSender1PokeSecondTimeToFail = ! _testPoke(sender1) ;