
type pokeMessage = {
    receiver : address,
    feedback : string
};

type storage = {
    pokeTraces : map<address, pokeMessage>,
    feedback : string,
    ticketOwnership : map<address,ticket<string>>  //ticket of claims
};

type return_ = [list<operation>, storage];

type parameter =
| ["Poke"]
| ["Init",address]
;

const poke = ([pokeTraces  , feedback  , ticketOwnership] : [map<address, pokeMessage>  , string  , map<address,ticket<string>>]) : return_ => {
    
    //extract opt ticket from map
    const [t , tom] : [option<ticket<string>>, map<address,ticket<string>>]  = Map.get_and_update(Tezos.get_source(), None() as option<ticket<string>>,ticketOwnership);
    
    return match(t, {
        None : () => failwith("User does not have tickets => not allowed"),
        Some : (_t : ticket<string>) => [  list([]) as list<operation>,{ //let t burn
        feedback,
        pokeTraces : Map.add(Tezos.get_source(), {receiver : Tezos.get_self_address(), feedback : ""},pokeTraces),
        ticketOwnership : tom 
     }]
    });
};

const init = ([a, pokeTraces  , feedback  , ticketOwnership] : [address, map<address, pokeMessage>  , string  , map<address,ticket<string>>]) : return_ => {

    return [  list([]) as list<operation>,{
        feedback,
        pokeTraces,
        ticketOwnership : Map.add(a,Tezos.create_ticket("can_poke", 1 as nat),ticketOwnership) 
     }];
};

/* Main access point that dispatches to the entrypoints according to
the smart contract parameter. */
const main = ([action, store] : [parameter, storage]) : return_ => {
    //destructure the storage to avoid DUP
    let {pokeTraces  , feedback  , ticketOwnership } = store;
    return match (action, {
        Poke: () => poke([pokeTraces  , feedback  , ticketOwnership]) ,
        Init: (a : address) => init([a, pokeTraces  , feedback  , ticketOwnership]),
      } 
    )
};
