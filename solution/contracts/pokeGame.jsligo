type pokeMessage = { receiver: address, feedback: string };

export type storage = {
  pokeTraces: map<address, pokeMessage>,
  feedback: string,
  ticketOwnership: map<address, ticket<string>>
};

type parameter = unit;

type returned_feedback = [address, string];

type oracle_param = contract<returned_feedback>;

type return_ = [list<operation>, storage];

/* @entry */
const poke = (_: parameter, store: storage): return_ => {
  const { pokeTraces, feedback, ticketOwnership } = store;
  const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
    Map.get_and_update(
      Tezos.get_source(),
      None() as option<ticket<string>>,
      ticketOwnership
    );
  return match(
    t,
    {
      None: () => failwith("User does not have tickets => not allowed"),
      Some: (_t: ticket<string>) =>
        [
          list([]) as list<operation>,
          {
            feedback,
            pokeTraces: Map.add(
              Tezos.get_source(),
              { receiver: Tezos.get_self_address(), feedback: "" },
              pokeTraces
            ),
            ticketOwnership: tom
          }
        ]
    }
  )
};

/* @no_mutation */
/* @entry */
const pokeAndGetFeedback = (oracleAddress: address, store: storage): return_ => {
  const { pokeTraces, feedback, ticketOwnership } = store;
  const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
    Map.get_and_update(
      Tezos.get_source(),
      None() as option<ticket<string>>,
      ticketOwnership
    );
  let feedbackOpt: option<string> =
    Tezos.call_view("feedback", unit, oracleAddress);
  return match(
    t,
    {
      None: () => failwith("User does not have tickets => not allowed"),
      Some: (_t: ticket<string>) =>
        match(
          feedbackOpt,
          {
            Some: (feedback: string) => {
              let feedbackMessage =
                { receiver: oracleAddress, feedback: feedback };
              return [
                list([]) as list<operation>,
                {
                  feedback,
                  pokeTraces: Map.add(
                    Tezos.get_source(),
                    feedbackMessage,
                    pokeTraces
                  ),
                  ticketOwnership: tom
                }
              ]
            },
            None: () =>
              failwith("Cannot find view feedback on given oracle address")
          }
        )
    }
  )
};

/* @view */
const feedback = ([_, store]: [unit, storage]): string => {
  return store.feedback
};

/* @entry */
const init = ([a, ticketCount]: [address, nat], store: storage): return_ => {
  const { pokeTraces, feedback, ticketOwnership } = store;
  if (ticketCount == (0 as nat)) {
    return [
      list([]) as list<operation>,
      { pokeTraces, feedback, ticketOwnership }
    ]
  } else {
    const t: ticket<string> =
      Option.unopt(Tezos.create_ticket("can_poke", ticketCount));
    return [
      list([]) as list<operation>,
      { pokeTraces, feedback, ticketOwnership: Map.add(a, t, ticketOwnership) }
    ]
  }
}; 